
# Сравнения симуляций вытекающих из Эйлера
  
Симулируем пружину с весом. 
- Сила из закона Гука - $F(x) = -k \cdot x$
- Сила из второго закона Ньютона - $\Sigma \vec{F} = m \cdot \vec{a}$
- Сила вязкости - $\vec{F} = -c \cdot \vec{V}$

Выразим в форме дифференциального уравнения
```math
\ddot{x} + 2d\omega_0\dot{x} + \omega_0^2 x = 0
```
где
```math
 d = \frac{c}{2 \sqrt{km}}, \omega_0 = \sqrt{\frac{k}{m}}$
```

Это же можно выразить через простой человеческий вектор 
```math
z =
    \begin{bmatrix}
        x \\
        \dot{x} 
    \end{bmatrix}$
```
Тогда и наше выражение примет форму:
```math
\dot{z} =
    \begin{bmatrix}
        0 & 1 \\
        -\omega_0^2 & -2d\omega_0 
    \end{bmatrix}
    \cdot z = A \cdot z 
```
Что с этим делать дальше каждый решает сам. Мы, например, построим явного и неявного (обратного) Эйлера:
```math
z_{k+1} = (I + A\cdot\Delta t)\cdot z_k = F\cdot z_k
```
```math
z_{k+1} = (I - A\cdot\Delta t)^{-1}\cdot z_k = B\cdot z_k
```


Теперь очень хочется посмотреть на то, насколько хорошо эти два подхода работают. Для этого есть manimEulerComparison.py (рендер ниже)

[![Euler Trajectory](https://img.youtube.com/vi/MI4oBvl97fQ/0.jpg)](https://www.youtube.com/watch?v=MI4oBvl97fQ)

# Сравнения Эйлера и Полу-Эйлера
Симулируем более общий случай. Имеем:
Силу $\vec{F}(simulation)$ которая действует на тело, умеем считать её для любой конфигурации объектов.

Тогда Эйлер для тела расписывается как:
```math
x_{i+1}  = x_{i} + v_{i} * dt \\
v_{i+1}  = v_{i} + {F} / m * dt
```
Или как
```math
$\begin{bmatrix} x_{i+1} \\ v_{i+1} \end{bmatrix} = \begin{bmatrix} 1 & dt \\ 0 & 1 \end{bmatrix} *  \begin{bmatrix} x_{i} \\ v_{i} \end{bmatrix} + \begin{bmatrix} 0 \\ dt * F/m \end{bmatrix}$ 
```
Вектор силы теперь зависит не только от позиции и скорости тела. В матричной форме выходит не так красиво, но это позволяет нам считать сложные системы с учётом комбинации многих тел в пространстве, просто просуммировав все силы действующие на точку и применив это линейное преобразование со сдвигом.

Полу-Ейлер возникает когда порядок обновлений скорости и позиции сменён, и для позиции используется новая скорость:
```math
v_{i+1}  = v_{i} + {F/m} * dt
```
```math
x_{i+1}  = x_{i} + v_{i+1} * dt
```
Или, если расписать в изначальном порядке:
```math
x_{i+1}  = x_{i} + (v_{i} + {F/m} * dt) * dt
```
```math
v_{i+1}  = v_{i} + {F/m} * dt
```
То есть 
```math
$\begin{bmatrix} x_{i+1} \\ v_{i+1} \end{bmatrix} = \begin{bmatrix} 1 & dt \\ 0 & 1 \end{bmatrix} *  \begin{bmatrix} x_{i} \\ v_{i} \end{bmatrix} + \begin{bmatrix} dt^{2} *F/m \\ dt * F/m \end{bmatrix}$ 
```
Как мы уже увидели выше, Эйлер и Обратный-Эйлер генерируют и теряют лишнюю энергию в системе. При меньших dt они ошибаются меньше, но всё так же расходятся довольно быстро. Приятное свойство Полу-Ейлера заключается в том, что для его схождения на достаточно большом временном промежутке достаточное dt сильно больше чем для Эйлера и Обратного-Ейлера, а значит и количество итераций требуется гораздо меньше. 
Об этом пример manimEulerTrajectory.py

[![Euler Trajectory](https://img.youtube.com/vi/4lyrtohI2Qo/0.jpg)](https://www.youtube.com/watch?v=4lyrtohI2Qo)

За счёт такого сильного снижение количества требуемых итераций - возможна практическая симуляций сложных систем, как например clothWithVerlet.

# Как запускать manim рендеринг

**ВАЖНО!** Если будете запускать у себя пример локально, то нужно

 - Поставить зависимости из requirements.txt
 - Убедится что стоит ffmpeg и он проброшен в системный путь
 - Проверить работоспособность LaTeX, он есть в зависимостях

Чтобы скомпилировать сцену SCENE из файла FILE.py используйте комманду

 
 Альтернативно можно запустить ноутбук или посмотреть итоговый результат в bin/EulerComparison.mp4
