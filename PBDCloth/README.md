# Симуляция тканей при помощи PBD

***Position Based Dynamics*** как метод основывается на описании и поддержании "ограничений" системы

Основной подход выглядит так: [(референс)](https://matthias-research.github.io/pages/publications/posBasedDyn.pdf)

```
forall vertices i
  initialize xi = x, vi = v
endfor
loop
  forall vertices i do vi ← vi + ∆twifext(xi)
  dampVelocities(v1,...,vN)
  forall vertices i do pi ← xi + ∆tvi
  forall vertices i do generateCollisionConstraints(xi → pi)
  loop solverIterations times
    projectConstraints(C1,..., CM+Mcoll , p1, ..., pN)
  endloop
  forall vertices i
    vi ← (pi −xi)/∆t
    xi ← pi
  endfor
  velocityUpdate(v1,...,vN)
endloop
```

В данном методе перед Полу-Эйлером применяется некоторый солвер констрайнов - метод который итерирует через все ограничения и наивно их разрешает. 
После нескольких итераций управление передаётся Полу-Эйлеру, и, в самом конце, вызывается *velocityUpdate*, который модифицирует вектор скоростей
на основе информации из солвера констрейнов (в статье предлагается добавлять упругий отскок для материальных точек применяя дампинг к вектору скоростей и отражая его по нормали каждого столкновения)

Выполняя только Полу-Эйлера с солвером можно получить модель которая будет симулировать столкновения и жёсткие расстояния, однако, без дампинга и обновления скоростей система может расходиться. 
Например констрейн колизии с полом без дампинга может привести к вращению, так как у нас нет упругово столкновения или трения:

![](bin/Cube_skewed_1iters_600frames.gif)

С этим можно бороться применяя дампинг (как в статье сразу после расчёта новых скоростей)

![](bin/Cube_skewed_1iters_600frames_0.1dump.gif)

Такой подход позволяет описать как расстояние между частицами (которое мы используме для симуляции поверхностей и тел), так и колижены, в явном
виде указав что частица не должна находиться внутри тела и в случае проникновения - проецировалась на поверхность.
